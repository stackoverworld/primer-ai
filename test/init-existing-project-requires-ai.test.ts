import { mkdtempSync, rmSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";

import { afterEach, describe, expect, it, vi } from "vitest";

const mocks = vi.hoisted(() => ({
  collectInitInput: vi.fn(),
  buildProjectPlan: vi.fn(),
  generateAiDraft: vi.fn(),
  createScaffoldFiles: vi.fn(),
  rootAgentsLineCount: vi.fn(() => 100),
  runAiQuickSetup: vi.fn(),
  prepareTargetDirectory: vi.fn(async () => undefined),
  writeScaffold: vi.fn(async () => undefined),
  ensureGitInit: vi.fn(() => ({ initialized: false, warning: null }))
}));

vi.mock("@clack/prompts", () => ({
  spinner: () => ({
    start: () => undefined,
    stop: () => undefined,
    error: () => undefined,
    message: () => undefined
  }),
  log: {
    info: () => undefined,
    warn: () => undefined,
    success: () => undefined,
    error: () => undefined
  }
}));

vi.mock("../src/core/prompts.js", () => ({
  collectInitInput: mocks.collectInitInput
}));

vi.mock("../src/core/plan.js", () => ({
  buildProjectPlan: mocks.buildProjectPlan
}));

vi.mock("../src/core/ai.js", () => ({
  generateAiDraft: mocks.generateAiDraft
}));

vi.mock("../src/core/templates.js", () => ({
  createScaffoldFiles: mocks.createScaffoldFiles,
  rootAgentsLineCount: mocks.rootAgentsLineCount
}));

vi.mock("../src/core/quick-setup.js", () => ({
  runAiQuickSetup: mocks.runAiQuickSetup
}));

vi.mock("../src/core/write.js", () => ({
  prepareTargetDirectory: mocks.prepareTargetDirectory,
  writeScaffold: mocks.writeScaffold,
  ensureGitInit: mocks.ensureGitInit
}));

describe("runInit for existing projects", () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it("fails fast when AI draft is unavailable", async () => {
    const tempDir = mkdtempSync(join(tmpdir(), "primer-ai-existing-"));
    writeFileSync(join(tempDir, "README.md"), "existing");

    mocks.collectInitInput.mockResolvedValue({
      projectName: "existing-app",
      description: "Migrate existing app context.",
      techStack: "TypeScript + Node.js",
      existingProject: true,
      projectShape: "api-service",
      targetAgent: "both",
      includeCursorRules: false,
      generationMode: "ai-assisted",
      aiProvider: "auto",
      initializeGit: false,
      runAiQuickSetup: false
    });

    mocks.buildProjectPlan.mockReturnValue({
      directories: [],
      scopedInstructions: [],
      repositoryAreas: [],
      verificationCommands: [],
      launchCommand: "npm run dev"
    });

    mocks.generateAiDraft.mockResolvedValue({
      draft: null,
      warning: "AI-assisted mode requested, but no compatible `codex` or `claude` binary was found."
    });

    try {
      const { runInit } = await import("../src/commands/init.js");
      await expect(runInit(tempDir, {})).rejects.toThrow(
        "AI-assisted mode requested, but no compatible `codex` or `claude` binary was found."
      );
      expect(mocks.createScaffoldFiles).not.toHaveBeenCalled();
      expect(mocks.writeScaffold).not.toHaveBeenCalled();
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("merges existing README.md instead of creating README.primer-ai.generated.md", async () => {
    const tempDir = mkdtempSync(join(tmpdir(), "primer-ai-readme-merge-"));
    writeFileSync(join(tempDir, "README.md"), "# Existing Project\n\nCurrent project documentation.\n");

    mocks.collectInitInput.mockResolvedValue({
      projectName: "existing-app",
      description: "Migrate existing app context.",
      techStack: "TypeScript + Node.js",
      existingProject: true,
      projectShape: "api-service",
      targetAgent: "codex",
      includeCursorRules: false,
      generationMode: "ai-assisted",
      aiProvider: "auto",
      initializeGit: false,
      runAiQuickSetup: false
    });

    mocks.buildProjectPlan.mockReturnValue({
      directories: [],
      scopedInstructions: [],
      repositoryAreas: [],
      verificationCommands: [],
      launchCommand: "npm run dev"
    });

    mocks.generateAiDraft.mockResolvedValue({
      draft: {
        mission: "Migrate existing app context.",
        architectureSummary: ["A", "B", "C"],
        initialModules: [
          { path: "src/a", purpose: "A" },
          { path: "src/b", purpose: "B" },
          { path: "src/c", purpose: "C" }
        ],
        apiSurface: ["GET /health", "POST /events"],
        conventions: ["c1", "c2", "c3", "c4"],
        qualityGates: ["npm run lint", "npm run test", "npm run build"],
        risks: ["r1", "r2"]
      },
      providerUsed: "codex"
    });

    mocks.createScaffoldFiles.mockReturnValue([
      {
        path: "README.md",
        content: `# Existing App\n\nGenerated summary.\n\n## Generated By primer-ai\n- Stack: TypeScript + Node.js\n`
      },
      {
        path: "AGENTS.md",
        content: "# AGENTS\n"
      }
    ]);

    try {
      const { runInit } = await import("../src/commands/init.js");
      await runInit(tempDir, {});

      expect(mocks.writeScaffold).toHaveBeenCalledTimes(1);
      const firstCall = mocks.writeScaffold.mock.calls[0] as unknown[] | undefined;
      const filesArg = (firstCall?.[2] as Array<{ path: string; content: string }> | undefined) ?? [];
      const optionsArg = (firstCall?.[4] as { allowOverwritePaths?: ReadonlySet<string> } | undefined) ?? {};
      const paths = filesArg.map((file) => file.path);

      expect(paths).toContain("README.md");
      expect(paths).not.toContain("README.primer-ai.generated.md");

      const mergedReadme = filesArg.find((file) => file.path === "README.md")?.content ?? "";
      expect(mergedReadme).toContain("# Existing Project");
      expect(mergedReadme).toContain("<!-- primer-ai:agent-context:start -->");
      expect(mergedReadme).toContain("## AI Agent Context (Managed by primer-ai)");
      expect(mergedReadme).toContain("## Generated By primer-ai");
      expect(optionsArg.allowOverwritePaths?.has("README.md")).toBe(true);
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("preserves conflicting files by default using .primer-ai.generated variants", async () => {
    const tempDir = mkdtempSync(join(tmpdir(), "primer-ai-force-default-"));
    writeFileSync(join(tempDir, "AGENTS.md"), "# Existing agents context\n");

    mocks.collectInitInput.mockResolvedValue({
      projectName: "existing-app",
      description: "Migrate existing app context.",
      techStack: "TypeScript + Node.js",
      existingProject: true,
      projectShape: "cli-tool",
      targetAgent: "codex",
      includeCursorRules: false,
      generationMode: "ai-assisted",
      aiProvider: "auto",
      initializeGit: false,
      runAiQuickSetup: false
    });
    mocks.buildProjectPlan.mockReturnValue({
      directories: [],
      scopedInstructions: [],
      repositoryAreas: [],
      verificationCommands: [],
      launchCommand: "npm run dev"
    });
    mocks.generateAiDraft.mockResolvedValue({
      draft: {
        mission: "Migrate existing app context.",
        architectureSummary: ["A", "B", "C"],
        initialModules: [
          { path: "src/a", purpose: "A" },
          { path: "src/b", purpose: "B" },
          { path: "src/c", purpose: "C" }
        ],
        apiSurface: ["GET /health", "POST /events"],
        conventions: ["c1", "c2", "c3", "c4"],
        qualityGates: ["npm run lint", "npm run test", "npm run build"],
        risks: ["r1", "r2"]
      },
      providerUsed: "codex"
    });
    mocks.createScaffoldFiles.mockReturnValue([
      {
        path: "AGENTS.md",
        content: "# New agents context\n"
      }
    ]);

    try {
      const { runInit } = await import("../src/commands/init.js");
      await runInit(tempDir, {});

      const firstCall = mocks.writeScaffold.mock.calls[0] as unknown[] | undefined;
      const filesArg = (firstCall?.[2] as Array<{ path: string; content: string }> | undefined) ?? [];
      const paths = filesArg.map((file) => file.path);
      expect(paths).toContain("AGENTS.primer-ai.generated.md");
      expect(paths).not.toContain("AGENTS.md");
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("overwrites conflicting scaffold paths when --force is set", async () => {
    const tempDir = mkdtempSync(join(tmpdir(), "primer-ai-force-overwrite-"));
    writeFileSync(join(tempDir, "AGENTS.md"), "# Existing agents context\n");

    mocks.collectInitInput.mockResolvedValue({
      projectName: "existing-app",
      description: "Migrate existing app context.",
      techStack: "TypeScript + Node.js",
      existingProject: true,
      projectShape: "cli-tool",
      targetAgent: "codex",
      includeCursorRules: false,
      generationMode: "ai-assisted",
      aiProvider: "auto",
      initializeGit: false,
      runAiQuickSetup: false
    });
    mocks.buildProjectPlan.mockReturnValue({
      directories: [],
      scopedInstructions: [],
      repositoryAreas: [],
      verificationCommands: [],
      launchCommand: "npm run dev"
    });
    mocks.generateAiDraft.mockResolvedValue({
      draft: {
        mission: "Migrate existing app context.",
        architectureSummary: ["A", "B", "C"],
        initialModules: [
          { path: "src/a", purpose: "A" },
          { path: "src/b", purpose: "B" },
          { path: "src/c", purpose: "C" }
        ],
        apiSurface: ["GET /health", "POST /events"],
        conventions: ["c1", "c2", "c3", "c4"],
        qualityGates: ["npm run lint", "npm run test", "npm run build"],
        risks: ["r1", "r2"]
      },
      providerUsed: "codex"
    });
    mocks.createScaffoldFiles.mockReturnValue([
      {
        path: "AGENTS.md",
        content: "# New agents context\n"
      }
    ]);

    try {
      const { runInit } = await import("../src/commands/init.js");
      await runInit(tempDir, { force: true });

      const firstCall = mocks.writeScaffold.mock.calls[0] as unknown[] | undefined;
      const filesArg = (firstCall?.[2] as Array<{ path: string; content: string }> | undefined) ?? [];
      const forceArg = firstCall?.[3] as boolean | undefined;
      const paths = filesArg.map((file) => file.path);
      expect(paths).toContain("AGENTS.md");
      expect(paths).not.toContain("AGENTS.primer-ai.generated.md");
      expect(forceArg).toBe(true);
    } finally {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });
});
