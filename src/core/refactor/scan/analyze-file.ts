import { readFileSync } from "node:fs";
import { dirname, posix } from "node:path";

import { MAX_BYTES_PER_FILE } from "./constants.js";
import { normalizeRelativePath, normalizeSlashPath, toModuleKey } from "./path-utils.js";
import type { AnalyzedFile } from "./types.js";

function isCommentLine(trimmed: string): boolean {
  return (
    trimmed.startsWith("//") ||
    trimmed.startsWith("/*") ||
    trimmed.startsWith("*") ||
    trimmed.startsWith("#") ||
    trimmed.startsWith("<!--")
  );
}

function isLowSignalComment(trimmed: string): boolean {
  return /obvious|simply|just|basically|self[- ]?explanatory|this function|this file|ai[- ]generated|generated by ai|as an ai|placeholder/i.test(
    trimmed
  );
}

function extractImportSpecifiers(line: string): string[] {
  const specifiers: string[] = [];
  const fromMatch = line.match(/\bfrom\s+["']([^"']+)["']/);
  if (fromMatch?.[1]) specifiers.push(fromMatch[1]);

  const requireMatch = line.match(/\brequire\(\s*["']([^"']+)["']\s*\)/);
  if (requireMatch?.[1]) specifiers.push(requireMatch[1]);

  const dynamicImportMatch = line.match(/\bimport\(\s*["']([^"']+)["']\s*\)/);
  if (dynamicImportMatch?.[1]) specifiers.push(dynamicImportMatch[1]);

  return specifiers;
}

function resolveRelativeImport(importerPath: string, specifier: string): string {
  const importerDir = normalizeSlashPath(dirname(importerPath));
  const importerBase = importerDir === "." ? "" : importerDir;
  const combined = posix.normalize(posix.join(importerBase, specifier));
  return toModuleKey(combined);
}

export function analyzeSourceFile(root: string, absolutePath: string): AnalyzedFile | null {
  let content: string;
  try {
    content = readFileSync(absolutePath, "utf8");
  } catch {
    return null;
  }

  if (Buffer.byteLength(content, "utf8") > MAX_BYTES_PER_FILE) {
    return null;
  }

  const path = normalizeRelativePath(root, absolutePath);
  const lines = content.split(/\r?\n/);

  let commentLines = 0;
  let lowSignalCommentLines = 0;
  let todoCount = 0;
  let importCount = 0;
  let internalImportCount = 0;
  let exportCount = 0;
  let functionCount = 0;
  let classCount = 0;
  const relativeImports: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    if (isCommentLine(trimmed)) {
      commentLines += 1;
      if (isLowSignalComment(trimmed)) {
        lowSignalCommentLines += 1;
      }
      if (/\b(?:TODO|FIXME|HACK|XXX|TECHDEBT)\b/i.test(trimmed)) {
        todoCount += 1;
      }
    }

    if (/^export\b/.test(trimmed) || /\bmodule\.exports\b/.test(trimmed)) {
      exportCount += 1;
    }

    if (/\bfunction\b/.test(trimmed) || /=>\s*{?$/.test(trimmed)) {
      functionCount += 1;
    }

    if (/\bclass\b/.test(trimmed)) {
      classCount += 1;
    }

    const importSpecifiers = extractImportSpecifiers(line);
    if (!importSpecifiers.length) continue;
    importCount += importSpecifiers.length;

    for (const specifier of importSpecifiers) {
      if (!specifier.startsWith(".")) continue;
      internalImportCount += 1;
      relativeImports.push(resolveRelativeImport(path, specifier));
    }
  }

  return {
    path,
    moduleKey: toModuleKey(path),
    lineCount: lines.length,
    commentLines,
    lowSignalCommentLines,
    todoCount,
    importCount,
    internalImportCount,
    fanIn: 0,
    exportCount,
    functionCount,
    classCount,
    relativeImports
  };
}
